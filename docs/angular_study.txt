- Dependency Injection là mâu thiết kế cho việc tạo và cung cấp một vài phần của chương trình cho các thành phần khác yêu cầu chúng
- Dependency có thể là service*, giá trị, chuỗi hoặc hàm 
- Có hai phần chính: Dependency Consumer và Dependency Provider. Tương tác qua 1 abstract là Injector
- Khi 1 dependency được yêu cầu, Injector sẽ kiểm tra trong registry có instance nào hay chưa, nếu chưa, 1 instance mới sẽ được tạo ra và lưu vào registry
- ProviderIn cho phép code optimizer Angular và JS loại bỏ những service ko được sử dụng
- Root level: Angulả chỉ tạo ra 1 instance và chia sẽ nó giữa các clas cần nó
- Cách thông thường để inject 1 dependency là khai báo nó trong hàm khởi tạo của class. Khi Angular tạo 1 instance mới từ 1 component, directive hoặc pipe class nó sẽ xác địch service hoặc dependency nào mà class cần bằng cách nhìn vào kiểu tham số của hàm
- Khi Angular phát hiện ra rằng 1 component dựa vào 1 service, đầu tiên nó sẽ kiểm tra injector có instance nào của service đã tồn tại hay chưa. Nếu instance của service được yêu cầu chưa tồn tại thì injector sẽ tạo instance thông qua provider đã được đăng ký và thêm nó vào injector trước khi trả về service cho Angular
---------------------------------------------
- Service là một phạm trù bao gồm bất kỳ giá trị, hàm hoặc tính năng nào mà một ứng dụng cần. Dịch vụ thường là một lớp có mục đích hẹp, được xác định rõ ràng. 
- Component là một loại class có thể sử dụng DI
- 1 Component chỉ nên chứa các thuộc tính và phương thức cho việc binding dữ liệu. Các tác vụ và tiến trình khác nên ủy quyền cho service (fetching data, validate,...)
- @Injectable() chỉ ra rằng Angular có thể sử dụng clas này trong hệ thống DI. 
- providedIn: 'root', có nghĩa là service này được cung cấp trong toàn bộ ứng dụng.
-----------------------------
- useClass xác định Angular DI sẽ dùng clas nào để khởi tạo và trả về instance
--------------------------------
- Theo mặc định HttpResponse chỉ trả về response body
- 2 lỗi khiến HTTP request fail: Lỗi kết nối và lỗi ở phá backend
- Error code do kết nối mạng là 0, do backend là 1 số tự thiết lập
- HttpClient trả về 1 cold observable (ngĩa là ko có request thật sự nào xảy ra cho tới khi observable được đăng ký)
- Một khi đã subrice, unsubrice sẽ hủy bỏ resquest đang tiến hành, có ích cho việc bất đồng bộ bởi vì nó sẽ tự hủy bỏ request nếu người dùng chuyển trang

- Interceptor thường là các hàm có thể chạy cho mỗi yêu cầu và có thể ảnh hưởng đến nội dung và luồng yêu cầu và phản hồi tổng thể. Có thể cài đặt nhiều interceptor, tạo thành một chuỗi interceptor trong đó mỗi interceptor xử lý yêu cầu hoặc phản hồi trước khi chuyển tiếp đến interceptor tiếp theo trong chuỗi.
- Có 2 dạng Interceptor: funtional (nên dùng vì nó có những hành vi dễ dự đoán) và DI-based
- Hầu hết HttpRequest và HttpResponse là bất biến và Interceptor cũng ko thể thay đổi trực dtiếp chúng. Vì vậy cần dùng .clone() để chỉnh sửa chúng